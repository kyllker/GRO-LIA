/*
 * Copyright (C) Sandra Sáez Raspeño - All Rights Reserved
 *
 * This file is part of Cellsignals.
 *
 * All information contained in this package is, and remains the property of
 * Sandra Sáez Raspeño. Copy and distribution of CellSignals or any result
 * generated by it is strictly forbidden unless prior written permission is
 * obtained from Sandra Sáez Raspeño.
 */

/**********************************************************************/
/*                                                                    */
/*                 DIFFUSION METHODS IMPLEMENTATION                   */
/*                                                                    */
/**********************************************************************/

#include "Grid.h"
#include <tuple>

std::vector<std::tuple<unsigned int, unsigned int> > indexes;

template <class C>
void Grid<C>::reaction(float dt) {
  for (int k = 0; k < this->reactions.size(); k++) {
    for (unsigned int row = 1; row < getLen()-1; row++) {
      for (unsigned int col = 1; col < getLen()-1; col++) {

	// Calculare rate
	for (int r = 0; r < reactions[k]->reactants.size(); r++) {
	  int id_signal_reactive = reactions[k]->reactants[r];
	  reactions[k]->rate *= _signalC(id_signal_reactive, row, col);
	}

	// Decrease the reactants
	for (int r = 0; r < reactions[k]->reactants.size(); r++) {
	  int id_signal_reactive = reactions[k]->reactants[r];
	  this->getCell(row, col)->incSignal(id_signal_reactive, (reactions[k]->rate * dt));
	}

	// Increase the products
	for (int p = 0; p < reactions[k]->products.size(); p++) {
	  int id_signal_product = reactions[k]->products[p];
	  this->getCell(row, col)->decSignal(id_signal_product, (reactions[k]->rate * dt));
	}
      }
    }
  }
}

template <class C>
void Grid<C>::original_diff(float dt) {
  std::vector<GSignal*>::iterator it_signal;
  vector<vector<double> > aux(this->len, vector<double>(this->len));
  for (it_signal = this->sig.begin(); it_signal != this->sig.end(); it_signal++) {
    int id = (*it_signal)->get_id();
    double kdiff = (*it_signal)->get_kdiff();
    double kdeg = (*it_signal)->get_kdeg();
    for (unsigned int row = 1; row < getLen()-1; row++) {
      for (unsigned int col = 1; col < getLen()-1; col++) {
	aux[row][col] = -6 * kdiff *_signalC(id,row,col) - kdeg*_signalC(id,row,col);
        aux[row][col] += kdiff * (
			  0.5*_signalC(id,row+1,col-1) + _signalC(id,row+1,col) + 0.5*_signalC(id,row+1,col+1)
			  + _signalC(id,row,col-1) + _signalC(id,row,col+1)
			  + 0.5*_signalC(id,row-1,col-1) + _signalC(id,row-1,col) + 0.5*_signalC(id,row-1,col+1));

      }
    }

    for (unsigned int row = 1; row < getLen()-1; row++) {
      for (unsigned int col = 1; col < getLen()-1; col++) {
	aux[row][col] = _signalC(id, row, col) + dt*aux[row][col];
	//printf("new concentration in (%u, %u) = %f\n", row, col, aux[row][col]);
	this->grid[row][col]->setValue(id, aux[row][col]);
      }
    }
  }
}

template <class C>
void Grid<C>::matrix_diff(float dt) {
  std::vector<GSignal*>::iterator it_signal;
  vector<vector<double> > aux(this->len, vector<double>(this->len));
  for (it_signal = this->sig.begin(); it_signal != this->sig.end(); it_signal++) {
    int id = (*it_signal)->get_id();
    double kdiff = (*it_signal)->get_kdiff();
    double kdeg = (*it_signal)->get_kdeg();
    vector<vector<float> > M = (*it_signal)->get_Matrix();
    int cycles = (*it_signal)->get_cycles();
    for (int ncycles = 0; ncycles < (*it_signal)->get_cycles(); ncycles++) {
      for (unsigned int row = 1; row < getLen()-1; row++) {
	for (unsigned int col = 1; col < getLen()-1; col++) {
	  aux[row][col] = M[1][1]*kdiff*_signalC(id,row,col) - kdeg*_signalC(id,row,col);
	  aux[row][col] += kdiff * (
			    M[0][0]*_signalC(id,row+1,col-1) + M[0][1]*_signalC(id,row+1,col) + M[0][2]*_signalC(id,row+1,col+1)
			    + M[1][0]*_signalC(id,row,col-1) + M[1][2]*_signalC(id,row,col+1)
			    + M[2][0]*_signalC(id,row-1,col-1) + M[2][1]*_signalC(id,row-1,col) + M[2][2]*_signalC(id,row-1,col+1));

	}
      }

      for (unsigned int row = 1; row < getLen()-1; row++) {
	for (unsigned int col = 1; col < getLen()-1; col++) {
	  aux[row][col] = _signalC(id, row, col) + dt*aux[row][col];
	  //printf("new concentration in (%u, %u) = %f\n", row, col, aux[row][col]);
	  this->grid[row][col]->setValue(id, aux[row][col]);
	}
      }
    }
  }
}

template <class C>
std::vector<C*> Grid<C>::_getNonEmptyNeighbors(int id, unsigned int mainRow, unsigned int mainCol) {
  std::vector<C*> nonEmptyCells;

  // If neighborhood is of type Moore
  if (this->neighborhood == 8) {
    for (unsigned int row = mainRow-1; row <= mainRow+1; row++) {
      for (unsigned int col = mainCol-1; col <= mainCol+1; col++) {
	if (this->grid[row][col]->getValue(id) != 0.0) {
	  nonEmptyCells.push_back(this->grid[row][col]);
	  std::tuple<unsigned int, unsigned int> position(row, col);
	  indexes.push_back(position);
	}
      }
    }
  } else if (this->neighborhood == 4) {
    for (unsigned int row = mainRow-1; row <= mainRow+1; row++) {
      for (unsigned int col = mainCol-1; col <= mainCol+1; col++) {
	if (row == mainRow || col == mainCol) {
	  if (this->grid[row][col]->getValue(id) != 0.0) {
	    nonEmptyCells.push_back(this->grid[row][col]);
	    std::tuple<unsigned int, unsigned int> position(row, col);
	    indexes.push_back(position);
	  }
	}
      }
    }	      
  }
  
  return nonEmptyCells;
}

// Version of diffusion inspired in a random walk
template <class C>
void Grid<C>::random_walk(float probability) {
  //vector<vector<double> > aux(this->len, vector<double>(this->len));
  std::vector<GSignal*>::iterator it_signal;
  std::random_device rd;
  std::mt19937 rng(rd());

  for (it_signal = this->sig.begin(); it_signal != this->sig.end(); it_signal++) {
    int id = (*it_signal)->get_id();
    int cycles = (*it_signal)->get_cycles();
    float r;
    vector<vector<vector<int> > > aux(this->len, vector<vector<int> >(this->len, vector<int>(2)));

    for (int ncycles = 0; ncycles < (*it_signal)->get_cycles(); ncycles++) {
      for (unsigned int row = 1; row < getLen()-1; row++) {
	for (unsigned int col = 1; col < getLen()-1; col++) {
	  // Check the timer of each particle and apply degradation
	  // IMPORTANTE: HAY QUE CHECKEAR QUE EL TIPO DE LA CELDA SEA DBCELL PARA APLICAR LA LLAMADA
	  unsigned int timer = (this->grid[row][col]->_getTimer(id));
	  auto sMap = this->grid[row][col]->getSignalsMap();
	  if (timer > 0 ) {
	    this->grid[row][col]->_setTimer(id, timer-1); 
	  } else {
	    // La señal se degrada y se saca del mapa de la celda
	    this->grid[row][col]->setValue(id, 0);
	    this->grid[row][col]->_setTimer(id, 0);
	    auto it = sMap.find (id);
	    sMap.erase(it);
	  }
	  // If it would be possible apply diffusion
	  if (this->grid[row][col]->getValue(id) == 0.0) {
	    std::uniform_real_distribution<double> real_uni(0.0,1.0);
	    //clock_gettime(CLOCK_MONOTONIC, &ts);
	    //srand((time_t)ts.tv_nsec);
	    r = real_uni(rng);

	    
	    if (probability == 1.0 || r < probability) {
	      std::vector<C*> neigh = _getNonEmptyNeighbors(id, row, col);
	      // Choose a random cell in neigh and change its state
	      if (neigh.size() != 0) {
		std::uniform_int_distribution<int> uni(0, neigh.size()-1);
		unsigned int randIndex = uni(rng);
		// Extract coordinates from tuple in indexes vector
		//unsigned int r, c;
		int choosenRow, choosenCol; 
		std::tie (choosenRow, choosenCol) = indexes[randIndex];
		aux[row][col][0] = 1.0;
		aux[row][col][1] = (this->grid[choosenRow][choosenCol]->_getTimer(id)/2);
		//neigh[randIndex]->setValue(id, 1);
		// Clear indexes vector
		indexes.clear();

		float change_prob = real_uni(rng);
		if (change_prob < 0.5) {
		  aux[choosenRow][choosenCol][0] = 0.0;
		  aux[choosenRow][choosenCol][1] = 0;
		  //this->grid[row][col]->setValue(id, 0);
		} else {
		  aux[choosenRow][choosenCol][0] = 1.0;
		  aux[choosenRow][choosenCol][1] = this->grid[choosenRow][choosenCol]->_getTimer(id);
		}
	      }
	    }
	  }
	}
      }

      for (unsigned int row = 1; row < getLen()-1; row++) {
	for (unsigned int col = 1; col < getLen()-1; col++) {
	  //aux[row][col] = _signalC(id, row, col) + dt*aux[row][col];
	  this->grid[row][col]->setValue(id, aux[row][col][0]);
	  this->grid[row][col]->_setTimer(id, aux[row][col][1]);
	}
      }
    }
  }
}

// Version of diffusion inspired in a random walk but taking into account the proportion of neighbors.
template <class C>
void Grid<C>::proportional_random_walk(float proportion) {
  std::vector<GSignal*>::iterator it_signal;
  std::random_device rd;
  std::mt19937 rng(rd());

  for (it_signal = this->sig.begin(); it_signal != this->sig.end(); it_signal++) {
    int id = (*it_signal)->get_id();
    int cycles = (*it_signal)->get_cycles();
    float r;
    vector<vector<double> > aux(this->len, vector<double>(this->len));

    for (int ncycles = 0; ncycles < (*it_signal)->get_cycles(); ncycles++) {
      for (unsigned int row = 1; row < getLen()-1; row++) {
	for (unsigned int col = 1; col < getLen()-1; col++) {
	  // If it would be possible apply diffusion
	  if (this->grid[row][col]->getValue(id) != 0.0) {
	    std::vector<C*> neigh = _getNonEmptyNeighbors(id, row, col);
	    // Choose a random cell in neigh and change its state if the neighborhood proportion it is greater than a threshold.
	    if ((this->neighborhood - neigh.size()) >= proportion) {
	      if (neigh.size() != 0) {
		std::uniform_int_distribution<int> uni(0, neigh.size()-1);
		std::uniform_real_distribution<double> real_uni(0.0,1.0);
		unsigned int randIndex = uni(rng);
		// Extract coordinates from tuple in indexes vector
		unsigned int r, c;
		std::tie (r, c) = indexes[randIndex];
		aux[r][c] = 1.0;
		indexes.clear();
		//neigh[randIndex]->setValue(id, 1);
	      
		float change_prob = real_uni(rng);
		if (change_prob < 0.5) {
		  aux[row][col] = 0.0;
		  //this->grid[row][col]->setValue(id, 0);
		} else {
		  aux[row][col] = 1.0;
		}
	      }
	    }
	  }
	}
      }

      for (unsigned int row = 1; row < getLen()-1; row++) {
	for (unsigned int col = 1; col < getLen()-1; col++) {
	  //aux[row][col] = _signalC(id, row, col) + dt*aux[row][col];
	  this->grid[row][col]->setValue(id, aux[row][col]);
	}
      }
    }
  }
}



template class Grid<CSCell>;
template class Grid<DBCell>;
